#!/bin/sh
#
# Pseudo-configure script for locating dx build tools
#
# This is intended to look like and mimic the behavior of a normal
# autoconf/configure script; but is really just a simple shell script for
# locating build tools on the local host.  As such, it's probably slower,
# buggier and less portable than the usual autoconf/configure tools.  On the
# other hand, it's more flexible in terms of cross-compiling, avoids some
# unnecessary (for dx) test and probably(?) simpler.
#
# This script searches the current PATH for necessary tools; and inserts
# those tool paths into the necessary Makefiles.  The goal here is to provide
# some measure of build portability across different platforms.  At a
# minimum, this script should work on Linux and cygwin.  Should probably work
# under *BSD, too, but not tested.  Other OS/environments are not supported.
#
# The script assumes that it can find 'which' and 'sed' in the current PATH.
# It (probably?) relies on some specific 'bash' features.  All other
# dependencies should be resolved by the script itself.
#
# Usage:
#	% configure [options] [tool-definitions]
#



#
# Tools used by the dx build process.  Some are required (e.g., for actually
# compiling the code); others are optional (e.g., only used for generating
# documentation)
#
OPTIONAL_TOOLS="DEBUGFS DOXYGEN E2FSCK MKISOFS"
REQUIRED_TOOLS="AR ASM CC CP NM OBJCOPY OBJDUMP SED SHELL TAR"



#
# Ensure this tool is available, either via the PATH or via absolute path
#
function find_tool
	{
	local status=0

	echo -n "Looking for $1 ... "

	local tool=`which $1 2>/dev/null`
	if [ -n "${tool}" ]; then
		# Found tool in current PATH
		echo ${tool}
		status=0

	elif [ -e $1 ]; then
		# Not in PATH, but user provided explicit path on command line
		echo $1
		status=0

	else
		echo "Not found!"
		status=1
	fi

	return $status
	}



#
# Show supported options + exit
#
function help
	{
	cat <<-END_OF_HELP

DX pseudo-configure script

Usage:
    $0 [-h|--help] [--host=<HOST-SPEC>] [TOOL-DEFINITIONS]

    -h, --help displays this help message

    --host=<HOST-SPEC> enables cross-compilation support.  Required for
      platforms that do not natively support ELF file format (typically, only
      cygwin?).  HOST-SPEC should be the usual "cpu-vendor-os" triplet.  For
      example, if your cross compiler is i686-pc-elf-gcc, then use
      --host=i686-pc-elf

    TOOL-DEFINITIONS are paths + overrides for specifying tools and tool
      locations.  For example, if you have gcc installed under
      /non/standard/path/to/my-gcc then add CC=/non/standard/path/to/my-gcc
      to the command line.

      These tools are required (in the PATH, in the environment or on the
      command-line):
        ${REQUIRED_TOOLS}

      These tools are optional.  If not present, some build features may be
      unavailable:
        ${OPTIONAL_TOOLS}

END_OF_HELP

	exit 1
	}





#
# main() #################################################################
#


#
# The 'which' tool is required; this script cannot proceed without it
#
WHICH=`which which 2>/dev/null`
if [ -z "${WHICH}" ]; then
	echo "Unable to find 'which' tool, required for configure operation"
	exit 2
fi



#
# Attempt to locate 'sed', for parsing --host values.  If not found, user can
# still override with SED=/path/to/sed on command line before --host value.
#
SED=`which sed 2>/dev/null`



#
# Parse the command line arguments, if any
#
for argument in $*; do
	case ${argument} in
		-d|--debug)
			# Enable debug support
			set -x
			;;


		-h|-?|--help)
			help
			;;


		--host=*)
			# Ensure sed is available first
			if [ -z "${SED}" ]; then
				echo "Error: Cannot process --host without 'sed'"
				echo "Try adding 'SED=/path/to/sed' definition to command line"
				exit 1
			fi

			# Assume the --host value is the prefix on the cross-tools (e.g.,
			# i386-elf-gcc)
			CROSS_COMPILE_PREFIX=`echo ${argument} | \
				${SED} 's/--host=\(.*\)/\1-/' -`

			if [ ${CROSS_COMPILE_PREFIX} != "-" ]; then
				echo "OK, will look for cross-tools (${CROSS_COMPILE_PREFIX})"
			else
				echo "Bad --host value"
				help
			fi
			;;


		*=*)
			# Assume this is an explicit definition or path to some tool (e.g,
			# CC=gcc, etc), so automatically include this definition locally
			# to override the defaults below
			eval ${argument}
			;;


		*)
			echo "Unrecognized argument: ${argument}"
			help
			;;
	esac
done



#
# Establish the basic tool definitions.  Values provided on the command line
# override the defaults provided here
#
AR=${AR:-ar}
ASM=${ASM:-${CROSS_COMPILE_PREFIX}as}
CC=${CC:-${CROSS_COMPILE_PREFIX}gcc}
CP=${CP:-cp}
DEBUGFS=${DEBUGFS:-debugfs}
DOXYGEN=${DOXYGEN:-doxygen}
E2FSCK=${E2FSCK:-e2fsck}
MKISOFS=${MKISOFS:-mkisofs}
NM=${NM:-nm}
OBJCOPY=${OBJCOPY:-objcopy}
OBJDUMP=${OBJDUMP:-objdump}
SED=${SED:-sed}
SHELL=${SHELL:-bash}
TAR=${TAR:-tar}



#
# Ensure the tools actually exist, either in the PATH or via the values given
# on the command line.  This does not actually invoke or validate the tools
# themselves -- a significant departure from the usual autoconf/configure
# behavior
#
for tool in ${REQUIRED_TOOLS}; do
	eval "find_tool \$${tool}"
	if [ $? -ne 0 ]; then
		echo "Error: Unable to find required tool: ${tool}"
		exit 1
	fi
done

for tool in ${OPTIONAL_TOOLS}; do
	eval "find_tool \$${tool}"
	if [ $? -ne 0 ]; then
		echo "Warning: Unable to find optional tool: ${tool}"
	fi
done



#
# Generate a sed script to insert the various tool definitions
#
SED_PROGRAM="$0.sed.$$"
echo > ${SED_PROGRAM}
for tool in ${REQUIRED_TOOLS} ${OPTIONAL_TOOLS}; do
	# The script is a series of "s/tool-pattern/tool-path/" commands
	eval "echo \"s,@${tool}@,\$${tool},g\" >> ${SED_PROGRAM}"
done

if [ ! -e ${SED_PROGRAM} ]; then
	echo "Unable to generate 'sed' program!"
	exit 1
fi



#
# Now generate the various makefiles, inserting these tool definitions where
# necessary
#
echo
echo "Generating output files ..."

OUTPUT_FILES="media/iso/Makefile \
			  media/floppy/load-image.sh \
			  src/Makefile.src"

for file in ${OUTPUT_FILES}; do
	if [ ! -e ${file}.in ]; then
		echo "Skipping missing input file: ${file}"
		continue
	fi

	# Create + fixup the output file with the detected tool settings
	${SED} -f ${SED_PROGRAM} --posix ${file}.in > ${file}
done



#
# Done.  Cleanup + exit
#
rm ${SED_PROGRAM}
echo "Done!"
echo
exit 0

